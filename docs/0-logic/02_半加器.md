# 加法器

## 半加器

半加器输入A、B（0或1），输出SUM、CARRY

- SUM：加法结果的最低位
- CARRY：进位（需要传给更高位）

半加器真值表

| 输入A | 输入B | 输出SUM | 输出CARRY |
| ----- | ----- | ------- | --------- |
| 0     | 0     | 0       | 0         |
| 0     | 1     | 1       | 0         |
| 1     | 0     | 1       | 0         |
| 1     | 1     | 0       | 1         |

对应实现真值表

```
SUM   = XOR
CARRY = AND
```

实现了加法器，计算机从“逻辑”迈向“算术”

## 全加器

全加器有三个输入

- A
- B
- Cin （低位进位的CARRY IN）

输出

- SUM
- Cout 进位（需要传给更高位）

全加器真值表

| 输入A | 输入B | 输入Cin | 输出SUM | 输出Cout |
| ----- | ----- | ------- | ------- | -------- |
| 0     | 0     | 0       | 0       | 0        |
| 0     | 0     | 1       | 1       | 0        |
| 0     | 1     | 0       | 1       | 0        |
| 0     | 1     | 1       | 0       | 1        |
| 1     | 0     | 0       | 1       | 0        |
| 1     | 0     | 1       | 0       | 1        |
| 1     | 1     | 0       | 0       | 1        |
| 1     | 1     | 1       | 1       | 1        |

全加器行为

```
SUM       = (A XOR B) XOR Cin
CARRY OUT = (A AND B) OR (Cin AND (A XOR B))
```

## Bit

> 一个 bit = 用来区分两个等可能事件所需的最小信息量
>
> —— Claude Shannon

如果一个问题只能回答「是 / 否」  
你只需要 1 bit 信息

1 bit → 只能表示 0 or 1

2 bit → 00、01、10、11 → 4 种状态

以此类推......

bit 是物理的，不是抽象的

```
我们写 0/1 是符号
CPU 实际使用的是:
高电压 / 低电压
充电 / 放电
电流通 / 电流断
磁极向上 / 向下
晶体管导通 / 截止
```

## 4-bit加法器

也叫波纹进位加法器 Ripple Adder

因为进位的传递像波纹一样

对两个 4-bit 二进制数执行加法计算

```
计算逻辑
 A3 A2 A1 A0
+B3 B2 B1 B0
--------------
 S3 S2 S1 S0     (Sum)
        Cout     (溢出进位)
        
       
计算：5+3=8
  0101   (5)
+ 0011   (3)
--------
  1000   (8)
```

## 边界和代价

4-bit : 0000到1111间16种值表示的空间

4-bit unsigned  范围 0 ~ 15，当计算超出边界，就会溢出（overflow）

当波纹进位长度长（64-bit），也有线性的时间代价，所以现代CPU有很多相关优化

