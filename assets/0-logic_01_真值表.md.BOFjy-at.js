import{_ as d,c as l,o as e,ae as a}from"./chunks/framework.BWO1lJ7q.js";const c=JSON.parse('{"title":"真值表","description":"","frontmatter":{},"headers":[],"relativePath":"0-logic/01_真值表.md","filePath":"0-logic/01_真值表.md"}'),i={name:"0-logic/01_真值表.md"};function s(r,t,n,h,o,p){return e(),l("div",null,[...t[0]||(t[0]=[a(`<h1 id="真值表" tabindex="-1">真值表 <a class="header-anchor" href="#真值表" aria-label="Permalink to &quot;真值表&quot;">​</a></h1><h2 id="基础逻辑" tabindex="-1">基础逻辑 <a class="header-anchor" href="#基础逻辑" aria-label="Permalink to &quot;基础逻辑&quot;">​</a></h2><ol><li>AND （逻辑与)</li></ol><ul><li>只有两个输入为1时，输出才为1，否则为0</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">输入 A</th><th>输入 B</th><th>输出 A AND B</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td>0</td><td>0</td></tr><tr><td style="text-align:left;">0</td><td>1</td><td>0</td></tr><tr><td style="text-align:left;">1</td><td>0</td><td>0</td></tr><tr><td style="text-align:left;">1</td><td>1</td><td>1</td></tr></tbody></table><ol start="2"><li>OR （或）</li></ol><ul><li>任意输入为1，输出为真</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">输入 A</th><th>输入 B</th><th>输出 A OR B</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td>0</td><td>0</td></tr><tr><td style="text-align:left;">0</td><td>1</td><td>1</td></tr><tr><td style="text-align:left;">1</td><td>0</td><td>1</td></tr><tr><td style="text-align:left;">1</td><td>1</td><td>1</td></tr></tbody></table><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ol><li><p><strong>布尔逻辑是所有数字电路的基础</strong></p><p>真值表 = 定义逻辑门行为的完整规范。</p></li><li><p>CPU、电路、门、加法器、寄存器的本质都是布尔函数组合。</p></li><li><p>不先掌握真值表，就无法理解电路如何实现加法，也无法理解计算机为何能算。</p></li></ol></div><hr><ol start="3"><li>XOR（异或）</li></ol><ul><li>对比输入是否<strong>不同</strong></li><li>输入不同，输出1</li><li>输入相同，输出0</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">输入 A</th><th>输入 B</th><th>输出 A XOR B</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td>0</td><td>0</td></tr><tr><td style="text-align:left;">0</td><td>1</td><td>1</td></tr><tr><td style="text-align:left;">1</td><td>0</td><td>1</td></tr><tr><td style="text-align:left;">1</td><td>1</td><td>0</td></tr></tbody></table><ol start="4"><li>NAND（与非）</li></ol><ul><li>当且仅当两个输入都为1时输出为0，否则为1</li><li>除了双真以外全部为真</li><li>原子性质逻辑</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">输入 A</th><th>输入 B</th><th>输出 A NAND B</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td>0</td><td>1</td></tr><tr><td style="text-align:left;">0</td><td>1</td><td>1</td></tr><tr><td style="text-align:left;">1</td><td>0</td><td>1</td></tr><tr><td style="text-align:left;">1</td><td>1</td><td>0</td></tr></tbody></table><h2 id="组合与可构造性" tabindex="-1">组合与可构造性 <a class="header-anchor" href="#组合与可构造性" aria-label="Permalink to &quot;组合与可构造性&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(A AND B) OR C</span></span></code></pre></div><table tabindex="0"><thead><tr><th>输入 A</th><th>输入 B</th><th>A AND B</th><th>输入 C</th><th>输出 (A AND B) OR C</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>组合 → 创造力，这意味着：</p><ul><li>多个真值表可以拼成更大的真值表</li><li>从简单逻辑可以推导出复杂计算</li></ul><h2 id="功能完备性" tabindex="-1">功能完备性 <a class="header-anchor" href="#功能完备性" aria-label="Permalink to &quot;功能完备性&quot;">​</a></h2><p>任何布尔表达式都能仅使用 NAND 实现</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>NOT A     = A NAND A</span></span>
<span class="line"><span>A AND B   = (A NAND B) NAND (A NAND B)</span></span>
<span class="line"><span>A OR  B   = (A NAND A) NAND (B NAND B)</span></span>
<span class="line"><span>A XOR B   = (A NAND B) NAND (A NAND (A NAND B)) NAND (B NAND (A NAND B))</span></span></code></pre></div>`,24)])])}const b=d(i,[["render",s]]);export{c as __pageData,b as default};
